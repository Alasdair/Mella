{-# LANGUAGE OverloadedStrings, PatternGuards #-}
module Lang.Term where

import Control.Applicative
import Control.Monad.Trans.State

import Data.List (elemIndex, intersperse)
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Word

import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as T

import Lang.Util.Counter
import Lang.PrettyPrint

-- | 'Index' is a datatype representing DeBruijn indices. It has
-- two fields 'dbInt', which is the actual index and 'dbName' which is the
-- name the variable was given by the user. This is useful for pretty-printing.
-- Indices in a term generated by the compiler may not have names.
data Index = DB { dbInt :: Int
                , dbName :: Text
                } deriving (Show)

-- | Two indices are equal if they have the same index - names don't matter.
-- This means that we don't have to worry about alpha-equivalence.
instance Eq Index where
    (DB n _) == (DB m _) = n == m

data Sort = Star | Box Word deriving (Show, Eq)

data Direction = LTR | RTL deriving (Show, Eq)

data Term = Sort Sort
          | Unnamed Index
          | Named Text
          | Pi Tag Term Term
          | Ann Term Term
          | App Term Term
          | J Term Term Term Term Term Term
          | Id Term Term Term
          | Lam Tag Term
          | Rewrite Direction Term Term
          | Refl
          | Meta Int
          deriving (Eq, Show)

-- | Tags are used to attach additional information to terms. Specifically,
-- for 'Lam' and 'Pi' terms, tags are used to store the name of the variable
-- they introduced. This is so we can easily pretty-print the terms with the
-- correct variable names, which is invaluable for error messages.
data Tag = Tag { toText :: Text } deriving (Show)

-- | For any two tags @x@ and @y@, @x == y = True@.
instance Eq Tag where
    (==) x = const True

-- | Bidirectional typechecking is a well-known technique used when implementing
-- type systems. It is discussed and utilised by Andres Loh, Conor McBride
-- and Wouter Swierstra in their paper 'A tutorial implementation of a
-- dependently typed lambda calculus'. In the paper, they
-- create a distinction between two classes of terms. Some terms are inferable,
-- meaning that their type can be inferred, while other terms are checkable.
-- In their paper, the distinction between the inferable
-- and checkable terms is strictly enforced by the grammars for these separate
-- types of terms. This coarse-grained distinction makes some operations on
-- terms quite difficult to implement, such as substitution.
-- Rather than have two completely distinct sets of terms (two term datatypes).
-- A predicate function can be defined which takes a term t and returns true
-- if t is inferable and false otherwise.
inf :: Term -> Bool
inf (Sort _) = True
inf (Unnamed _) = True
inf (Named _) = True
inf (Pi _ s t) = inf s && inf t
inf (Ann _ _) = True
inf (App f x) = inf f
inf (Id _ _ _) = True
inf (Lam _ _) = False
inf (Rewrite _ _ _) = False
inf Refl = False
inf (J _ _ _ _ _ _) = True
inf (Meta _)  = False

-- | Perform a catamorphism over the structure of terms. The @int@ arguments
-- can be used to keep track of indices.
cata :: Int -> (Int -> Term -> Term) -> Term -> Term
cata n f (Pi tag s t) = f n $ Pi tag (cata n f s) (cata (n + 1) f t)
cata n f (Ann t ty) = f n $ Ann (cata n f t) (cata n f ty)
cata n f (App g x) = f n $ App (cata n f g) (cata n f x)
cata n f (Id ty t1 t2) = f n $ Id (cata n f ty) (cata n f t1) (cata n f t2)
cata n f (Lam tag expr) = f n $ Lam tag (cata (n + 1) f expr)
cata n f (Rewrite dir eq t) = f n $ Rewrite dir (cata n f eq) (cata n f t)
cata n f x = f n x

unsafeNF :: Ctx -> Term -> Term
unsafeNF ctx = either (\name -> error (show name ++ ": is not defined")) id . nf ctx

nf :: Ctx -> Term -> Either Text Term
nf ctx (J a b c d e f)    = return $ App c d
nf ctx (Id ty t1 t2)      = liftA3 Id (nf ctx ty) (nf ctx t1) (nf ctx t2)
nf ctx (Ann t ty)         = nf ctx t
nf ctx (Rewrite dir eq t) = liftA2 (Rewrite dir) (nf ctx eq) (nf ctx t)
nf ctx (Named name)       = nf ctx =<< (maybe (Left name) Right $ fst <$> Map.lookup name (named ctx))
nf ctx (Lam tag t)        = Lam tag <$> nf ctx t
nf ctx (Pi tag s t)       = liftA2 (Pi tag) (nf ctx s) (nf ctx t)
nf ctx t                  = case betaReduce ctx t of
                              Left name -> Left name
                              Right Nothing -> Right t
                              Right (Just t') -> nf ctx t'

betaReduce :: Ctx -> Term -> Either Text (Maybe Term)
betaReduce ctx (App (Lam _ f) x)  = Right . Just . shift (-1) 0 $ subst 0 (shift 1 0 x) f
betaReduce ctx (App (Pi _ s t) x) = Right . Just . shift (-1) 0 $ subst 0 (shift 1 0 x) t
betaReduce ctx (App f x)
  | nf ctx f /= Right f           = betaReduce ctx =<< flip App x <$> nf ctx f
betaReduce ctx x                  = Right Nothing

-- | 'shift' renumbers the indices of free variables within terms.
-- @shift d c t@ is the d-place shift of a term t above cutoff c
shift :: Int -> Int -> Term -> Term
shift d c (Unnamed (DB n name))
  | n < c                     = Unnamed (DB n name)
  | n >= c                    = Unnamed (DB (n + d) name)
shift d c (Lam tag f)         = Lam tag (shift d (c + 1) f)
shift d c (Pi tag s t)        = Pi tag (shift d c s) (shift d (c + 1) t)
shift d c (App f x)           = App (shift d c f) (shift d c x)
shift d c (Ann t ty)          = Ann (shift d c t) (shift d c ty)
shift d c (Id ty a b)         = Id (shift d c ty) (shift d c a) (shift d c b)
shift d c (Rewrite dir eq t)  = Rewrite dir (shift d c eq) (shift d c t)
shift d c x                   = x

subst :: Int -> Term -> Term -> Term
subst n x (Unnamed m)
  | n == dbInt m             = x
subst n x (Lam tag f)        = Lam tag $ subst (n + 1) (shift 1 0 x) f
subst n x (Rewrite dir eq t) = Rewrite dir (subst n x eq) $ subst n x t
subst n x (Pi tag s t)       = Pi tag (subst n x s) (subst (n + 1) (shift 1 0 x) t)
subst n x (Ann t1 t2)        = Ann (subst n x t1) (subst n x t2)
subst n x (App t1 t2)        = App (subst n x t1) (subst n x t2)
subst n x (Id ty t1 t2)      = Id (subst n x ty) (subst n x t1) (subst n x t2)
subst n x t                  = t

-- | By default, after a term is parsed, all the variables within are free.
-- `assignVars' takes such a term and assigns the free variables using
-- surrounding lambda terms as well as the provided `Ctx'.
assignVars :: Ctx -> Term -> Term
assignVars ctx = assignVars' ctx []

assignVars' :: Ctx -> [Text] -> Term -> Term
assignVars' ctx xs (Lam (Tag tag) expr) = Lam (Tag tag) $ assignVars' ctx (tag : xs) expr
assignVars' ctx xs (Pi (Tag tag) t1 t2) =
    Pi (Tag tag) (assignVars' ctx xs t1) (assignVars' ctx (tag : xs) t2)

assignVars' ctx xs (Named x) =
    case elemIndex x (xs ++ map (toText . fst) (unnamed ctx)) of
      Nothing -> Named x
      Just n -> Unnamed (DB n x)

assignVars' ctx xs (Ann t1 t2) =
    Ann (assignVars' ctx xs t1) (assignVars' ctx xs t2)

assignVars' ctx xs (Id ty t1 t2) =
    Id (assignVars' ctx xs ty) (assignVars' ctx xs t1) (assignVars' ctx xs t2)

assignVars' ctx xs (App t1 t2) =
    App (assignVars' ctx xs t1) (assignVars' ctx xs t2)

assignVars' ctx xs (Rewrite dir eq t) =
    Rewrite dir (assignVars' ctx xs eq) (assignVars' ctx xs t)

assignVars' ctx xs (J a b c d e f) = J (assignVars' ctx xs a) (assignVars' ctx xs b)
                                       (assignVars' ctx xs c) (assignVars' ctx xs d)
                                       (assignVars' ctx xs e) (assignVars' ctx xs f)

assignVars' ctx xs term = term

fixNames :: Ctx -> Term -> Term
fixNames = fixNames' 0

nth :: Int -> [a] -> Maybe a
nth n xs | n < 0 = Nothing
nth _ []         = Nothing
nth 0 (x:_)      = Just x
nth n (_:xs)     = nth (n - 1) xs

fixNames' :: Int -> Ctx -> Term -> Term
fixNames' m (Ctx bs _) (Unnamed (DB n _))
    | Just v <- nth (n - m) bs     = Unnamed $ DB n (toText . fst $ v)
fixNames' m ctx (Lam tag expr)     = Lam tag (fixNames' (m + 1) ctx expr)
fixNames' m ctx (Pi tag s t)       = Pi tag (fixNames' m ctx s) (fixNames' (m + 1) ctx t)
fixNames' m ctx (App t1 t2)        = App (fixNames' m ctx t1) (fixNames' m ctx t2)
fixNames' m ctx (Id ty t1 t2)      = Id (fixNames' m ctx ty) (fixNames' m ctx t1) (fixNames' m ctx t2)
fixNames' m ctx (Rewrite dir eq t) = Rewrite dir (fixNames' m ctx eq) (fixNames' m ctx t)
fixNames' m ctx (Ann t1 t2)        = Ann (fixNames' m ctx t1) (fixNames' m ctx t2)
fixNames' m ctx (J a b c d e f)    = J (fixNames' m ctx a) (fixNames' m ctx b) (fixNames' m ctx c)
                                       (fixNames' m ctx d) (fixNames' m ctx e) (fixNames' m ctx f)
fixNames' m ctx t                  = t

numberMetas :: Term -> State Counter Term
numberMetas (Meta _)           = do { n <- state count; return (Meta n) }
numberMetas (Pi tag t1 t2)     = liftA2 (Pi tag) (numberMetas t1) (numberMetas t2)
numberMetas (Lam tag t)        = Lam tag <$> numberMetas t
numberMetas (Ann t ty)         = liftA2 Ann (numberMetas t) (numberMetas ty)
numberMetas (App f x)          = liftA2 App (numberMetas f) (numberMetas x)
numberMetas (Id ty t1 t2)      = liftA3 Id (numberMetas ty) (numberMetas t1) (numberMetas t2)
numberMetas (Rewrite dir eq t) = liftA2 (Rewrite dir) (numberMetas eq) (numberMetas t)
numberMetas x                  = pure x

reconstructMeta :: Map Int Term -> Term -> Term
reconstructMeta m (Meta n)           = reconstructMeta m (Map.findWithDefault (Meta n) n m)
reconstructMeta m (Lam tag f)        = Lam tag $ reconstructMeta m f
reconstructMeta m (Rewrite dir eq t) = Rewrite dir (reconstructMeta m eq) $ reconstructMeta m t
reconstructMeta m (Pi tag s t)       = Pi tag (reconstructMeta m s) (reconstructMeta m t)
reconstructMeta m (Ann t1 t2)        = Ann (reconstructMeta m t1) (reconstructMeta m t1)
reconstructMeta m (App t1 t2)        = App (reconstructMeta m t1) (reconstructMeta m t2)
reconstructMeta m (Id ty t1 t2)      = Id (reconstructMeta m ty) (reconstructMeta m t1) (reconstructMeta m t2)
reconstructMeta m t                  = t

piBinders :: [(Text, Term)] -> Term -> Term
piBinders ts = assignVars emptyCtx . flip (foldr (uncurry Pi)) ts' . shift arity 0
    where arity = length ts
          ts' = map (\(n, (name, term)) -> (Tag name, shift n 0 term)) $ zip [0..] ts

lamBinders :: [Text] -> Term -> Term
lamBinders ts = assignVars emptyCtx . flip (foldr Lam) (map Tag ts) . shift arity 0
    where arity = length ts

data Ctx = Ctx { unnamed :: [(Tag, Term)]
               , named :: Map Text (Term, Term)
               } deriving (Show)

emptyCtx = Ctx [] Map.empty

-- Pretty Printing Terms
instance PrettyPrint Index where
    pretty sch (DB n name) = T.append (withColor sch unnamedColor name)
                              (if showIndices sch
                               then withColor sch indexColor (T.pack (show n))
                               else "")

instance PrettyPrint Tag where
    pretty sch (Tag t) = withColor sch unnamedColor t

instance PrettyPrint Direction where
    pretty sch RTL = withColor sch keywordColor "rtl"
    pretty sch LTR = withColor sch keywordColor "ltr"

instance PrettyPrint Sort where
    pretty sch Star = withColor sch sortColor "*"
    pretty sch (Box n) = withColor sch sortColor $ T.append "□ " (T.pack (show n))

instance PrettyPrint Term where
    pretty sch (Sort s) = pretty sch s
    pretty sch (Unnamed v) = pretty sch v
    pretty sch (Named v) = withColor sch unnamedColor v

    pretty sch pi@(Pi _ _ _) = prettyPi [] sch pi

    pretty sch (Ann t1 t2) =
        T.concat ["(", pretty sch t1, " :: ", pretty sch t2, ")"]

    pretty sch (App t1 t2) = T.concat [pretty sch t1, " ", prettyBracket sch t2]

    pretty sch (Id ty t1 t2) = T.concat [ "Id ", prettyBracket sch ty
                                        , " ", prettyBracket sch t1
                                        , " ", prettyBracket sch t2
                                        ]

    pretty sch (Lam tag expr) = T.concat [ withColor sch keywordColor "λ "
                                         , pretty sch tag
                                         , " → "
                                         , pretty sch expr
                                         ]

    pretty sch (Rewrite dir eq t) = T.concat [ withColor sch keywordColor "rewrite "
                                             , pretty sch dir
                                             , " ", prettyBracket sch eq
                                             , " ", prettyBracket sch t
                                             ]

    pretty sch (J a b c d e f) = T.concat [ withColor sch keywordColor "elimJ "
                                          , prettyBracket sch a, " ", prettyBracket sch b, " ", prettyBracket sch c, " "
                                          , prettyBracket sch d, " ", prettyBracket sch e, " ", prettyBracket sch f
                                          ]
    pretty sch Refl = withColor sch keywordColor "refl"
    pretty sch (Meta n) = withColor sch keywordColor (T.pack ("?" ++ show n))

    prettyBracket sch (Named v) = pretty sch (Named v)
    prettyBracket sch (Unnamed n) = pretty sch (Unnamed n)
    prettyBracket sch x = T.concat ["(", pretty sch x, ")"]

prettyList :: ColorScheme -> [Term] -> Text
prettyList sch xs = T.concat . intersperse " " $ map (pretty sch) xs

prettyPi ts sch (Pi tag@(Tag t) t1 t2)
  | t == "_"       = T.concat [prettyBracket sch t1, " -> ", pretty sch t2]
  | isPi t2        = T.concat ["(", vlist, " : ", pretty sch t1, ") ", pretty sch t2]
  | otherwise      = T.concat ["(", vlist, " : ", pretty sch t1, ") -> ", pretty sch t2]
  where
    isPi (Pi (Tag "_") _ _) = False
    isPi (Pi _ _ _)         = True
    isPi _                  = False

    isSamePi _ (Pi (Tag "_") _ _) = False
    isSamePi a (Pi _ b _)
      | a == b    = True
      | otherwise = False
    isSamePi _  _ = False

    vlist | null ts   = pretty sch tag
          | otherwise =  T.concat [prettyList sch ts, " ", pretty sch tag]
